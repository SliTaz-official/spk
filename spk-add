#!/bin/sh
#
# Spk-add - Install SliTaz packages. Read the README before adding or
# modifing any code in spk!
#
# Copyright (C) SliTaz GNU/Linux - BSD License
# Author: See AUTHORS files
#
. /usr/lib/slitaz/libspk.sh

tmpdir="/tmp/spk/$RANDOM"

#
# Functions
#

# Help and usage
usage() {
	name=$(basename $0)
	cat << EOT

$(boldify $(gettext "Usage:")) $name [packages|--options]

$(gettext "Install SliTaz Packages")

$(boldify $(gettext "Options:"))
  --forced    $(gettext "Force package reinstallation")
  --root=     $(gettext "Set the root file system path")
  --debug     $(gettext "Display some usefull debug information")

$(boldify $(gettext "Examples:"))
  $name package1 package2 packageN

EOT
	exit 0
}

# Update system databases
update_databases() {
	if [ -f $root/usr/bin/update-desktop-database ] && [ -n "$updatedesktopdb" ]; then
		chroot "$root/" /usr/bin/update-desktop-database /usr/share/applications 2>/dev/null
	fi
	# Mimetypes
	if [ -f $root/usr/bin/update-mime-database ] && [ -n "$updatemimedb" ]; then
		chroot "$root/" /usr/bin/update-mime-database /usr/share/mime
	fi
	# Icons
	if [ -f $root/usr/bin/gtk-update-icon-cache ] && [ -n "$updateicondb" ]; then
		chroot "$root/" /usr/bin/gtk-update-icon-cache /usr/share/icons/hicolor
	fi
	# Glib schemas
	if [ -f $root/usr/bin/glib-compile-schemas ] && [ -n "$compile_schemas" ]; then
		chroot "$root/" /usr/bin/glib-compile-schemas /usr/share/glib-2.0/schemas
	fi
	# Kernel modules
	if [ -f $root/sbin/depmod ] && [ -n "$updatedepmod" ]; then
		chroot "$root/" /sbin/depmod -a
	fi
}

# This function installs a package in the rootfs.
# Parameters: package_name package_file
install_package() {
	local package_file=$1

	# Never used I think!!!
	# Set by receipt: pre_depends() DEPENDS SELF_INSTALL CONFIG_FILES post_install()

	# Create package path early to avoid dependencies loop
	mkdir -p $tmpdir
	extract_receipt $tmpdir $package_file
	source $tmpdir/receipt

	local package_name=$PACKAGE
	local package_dir="$installed/$package_name"
	mkdir -p $package_dir

	# Run pre_depends from receipt if it exists
	if grep -q ^pre_depends $tmpdir/receipt; then
		pre_depends $root
	fi

	# Resolve package deps.
	if missing_deps $package_name $DEPENDS; then
		install_deps $package_name $DEPENDS
	fi

	newline
	boldify $(gettext "Installation of:") $package_name
	separator
	gettext "Copying"; echo -n " $package_name..."
	cp $package_file $tmpdir
	status

	# Add package checksum to $installed.$SUM
	[ "$verbose" ] && gettext "Adding package to:"; \
		echo -n " $(basename $installed.$SUM)"
	sed -i "/$(basename $package_file)/"d $installed.$SUM
	$CHECKSUM $(basename $package_file) >> $installed.$SUM
	[ "$verbose" ] && status

	# Extract Package
	cd $tmpdir || exit 1
	rm receipt
	spk-archive extract $package_file
	cd - >/dev/null

	# Get files to remove if upgrading
	local files_to_remove
	if [ -f $package_dir/files.list ]; then
		for file in $(cat $package_dir/files.list)
		do
			egrep -q "^$(echo $file | grepesc)$" $tmpdir/files.list && continue
			local modifiers=$(cat $package_dir/modifiers 2> /dev/null; \
				fgrep -sl $package_dir */modifiers | cut -d/ -f1)
			for i in modifiers; do
				egrep -qs "^$(echo $file | grepesc)$" $i/files.list && continue 2
			done
			files_to_remove="$files_to_remove $file"
		done
	fi
	debug "file_to_remove: $files_to_remove"

	# Create list of all possibly modified files
	local file_list
	for i in $(fgrep -v [ $tmpdir/files.list); do
		[ -e "${root}${i}" ] || continue
		[ -d "${root}${i}" ] && continue
		file_list="$file_list $i"
	done

	debug "file_list is set"

	# Check possibly modified files against other packages files.list
	debug "check modified files"
	for file in $file_list
	do
		local filegrep=$(egrep ^${file}$ $installed/*/files.list)
		if [ "$filegrep" ]; then
			local list=$(echo $filegrep | cut -d ":" -f 1)
			for pkg_file in $list; do
				local name=$(basename $(dirname $pkg_file))
				[  "$pkg" == "$name" ] && continue 2
				eval_gettext "Conflict package: \$name"; newline
				# If confirm is set, ask to remove
				if ! $confirm || gettext "Remove " && confirm; then
					spk-rm $name
				else
					eval_gettext "Warning! /$file will be overwritten!"; newline
					eval_gettext "If you remove /$package_name, be sure to reinstall $name"; newline
				fi
			done
		fi
	done

	cd $tmpdir || exit 1
	cp receipt files.list $package_dir

	# Copy the description if found.
	[ -f "description.txt" ] && cp description.txt $package_dir

	# Pre install commands.
	if grep -q ^pre_install $package_dir/receipt; then
		pre_install $root
	fi

	# Handle Config Files from receipt
	if [ -n "$CONFIG_FILES" ]; then
		cd $fs || exit 1
		# save 'official' configuration files
		eval_gettext "Saving configuration files for \$package_name... "

		local confs
		for i in $CONFIG_FILES; do
			confs="$confs $(find ${i#/} -type f 2> /dev/null)"
		done

		echo $confs | cpio -o -H newc --quiet | gzip -9 > \
			$package_dir/volatile.cpio.gz

		# keep user configuration files
		for configfile in $confs; do
			[ -e $configfile ] || continue
			cp -a $configfile fs/$configfile
		done
		status
		cd - >/dev/null
	fi

	# Merge ROOT_FS with Package FS
	gettext "Installing in:"; echo -n " $root/"
	cp -a fs/* $root/
	status

	# Remove old config files
	if [ "$files_to_remove" ]; then
		gettext "Removing old"; echo -n " $package_name..."
		for file in $files_to_remove; do
			if [ "$verbose" ]; then
				gettext "Removing:"; echo " ${root}${file}"
			fi
			remove_with_path ${root}${file}
		done
		status
	fi
	cd - >/dev/null

	# Remove the temporary directory.
	gettext "Removing all tmp files... "
	rm -rf $tmpdir
	status

	# Post install commands.
	if grep -q ^post_install $package_dir/receipt; then
		post_install $root
	fi

 	# Update-desktop-database if needed.
	if [ "$(fgrep .desktop $package_dir/files.list | fgrep /usr/share/applications/)" ]; then
		updatedesktopdb=yes
	fi
	# Update-mime-database if needed.
	if [ "$(fgrep /usr/share/mime $package_dir/files.list)" ]; then
		updatemimedb=yes
	fi
	# Update-icon-database
	if [ "$(fgrep /usr/share/icon/hicolor $package_dir/files.list)" ]; then
		updateicondb=yes
	fi
	# Compile glib schemas if needed.
	if [ "$(fgrep /usr/share/glib-2.0/schemas $package_dir/files.list)" ]; then
		compile_schemas=yes
	fi
	# Update depmod list
	if [ "$(fgrep /lib/modules $package_dir/files.list)" ]; then
		updatedepmod=yes
	fi
	separator
	eval_gettext "\$package_name (\$VERSION\$EXTRAVERSION) is installed."; newline
	newline
}

# Install .tazpkg packages.
# Parameters: package_file
install_local() {
	package_file="$1"
	check_valid_tazpkg $package_file
	install_package $package_file
	update_databases
}

# Download and install a package. TODO: Handle Undigest Mirrors
# Parameters: package_name
install_web() {
	local package_name="$1"

	# Check if get-Package
	if ! is_package_mirrored $package_name; then
		package_name="get-$package_name"
		AUTOEXEC=true
	fi

	# Check if package is mirrored
	if ! is_package_mirrored $package_name; then
		gettext "Could not find package on mirror:"; echo " $package_name"
		exit 1
	fi

	# package_full=Package-Version
	local package_full=$(full_package $package_name)

	cd $CACHE_DIR > /dev/null
	if [ -f "$package_full.tazpkg" ]; then
		[ "$count" == 1 ] && newline
		gettext "Using cache:"; echo " $(colorize "$package_full" 34)"
		# Check package download was finished
		if ! tail -c 2k $package_full.tazpkg | fgrep -q 00000000TRAILER; then
			eval_gettext "Continuing \$package_name download"; newline
			download "$package_full.tazpkg"
		fi
		# Check that the package has the correct checksum
		#if [ "$($CHECKSUM $package_full.tazpkg)" != "$(fgrep \"  $package_full.tazpkg\" $pkgsmd5)" ]; then
		#	rm -f $package.tazpkg
		#	download "$package_full.tazpkg"
		#fi
	else
		newline
		download "$package_full.tazpkg"
	fi

	install_package "$CACHE_DIR/$package_full.tazpkg"

	[ -n "$AUTOEXEC" ] && $package_name $root
	update_databases
}

# Install all missing deps. Auto install or ask user then install all missing
# deps from local dir, cdrom, media or from the mirror. In case we want to
# install packages from local, we need a packages.list to find the version.
# Parameters: package List of deps to install
install_deps() {
	local package=$1
	shift
	local deps="$@"

	gettext "Install all missing dependencies? "

	# Print Yes/No and get result
	if $AUTO_INSTALL_DEPS || confirm; then
		for pkgorg in $deps; do
			local pkg=$(equivalent_pkg $pkgorg)
			# Check if package is not installed
			if [ ! -d "$installed/$pkg" ]; then
				if [ ! -f "$PKGS_DB/packages.list" ]; then
					tazpkg recharge
				fi
				spk-add $pkg
			fi
		done
	else
		newline
		boldify $(gettext "Package:") $package
		gettext \
			"Dependencies unresolved. Installed but will probably not work."
		newline && newline
	fi
}

#
# Commands and exit
#

case "$1" in
	""|*usage|*help) usage ;;
esac

#
# Handle packages: package package.tazpkg ... packageN packageN.tazpkg
#

: ${count=0}
check_root

for pkg in $@
do
	case "$pkg" in
		*.tazpkg|*.spk)
			[ "$forced" ] || check_installed $(package_name $package_file)
			echo "Local package"
			#install_local $pkg
			;;
		--*) continue ;;
		*)
			[ "$forced" ] || check_installed $pkg
			count=$(($count + 1))
			install_web $pkg ;;
	esac
done
exit 0
